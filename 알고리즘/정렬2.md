### 목차

3. [**삽입 정렬(Insertion Sort)**](#3-삽입-정렬(Insertion-Sort))
4. [**퀵 정렬(Quick Sort)**](#4-선택-정렬(Quick-Sort))
5. [**병합 정렬(Merge Sort)**](#5-병합-정렬(Merge-Sort))


# 3. 삽입 정렬(Insertion Sort)

- 다시하기...............
</br>

- 정렬 과정
  - ㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇ
  - ㅇㅇㅇㅇㅇㅇㅇㅇㅇ
</br>
      <img width="600" src="">
<br/>
</br>

> ## Java 코드

  ```
    
  ```

> ## 시간복잡도

- ㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇ O(n²)으로 동일하다.
- 
<br/>


<br/>
<br/>

# 2. 퀵 정렬(Quick Sort)

- 주어진 배열을 두 개로 분할하고, 각각을 정렬하는 알고리즘이다.
- 이 때, 분할은 기준 아이템(pivot item)을 중심으로 이루어진다.
- 다른 원소와 비교만으로 정렬을 수행하는 비교 정렬에 속하며, 배열을 비균등하게 분할한다.
- 불안정 정렬(Unstable Sort)이다.
</br>

- 정렬 과정
  - 여기다시해야함!!!!!!!!!!!!!!
  - 
</br>
      <img width="600" src="">
<br/>
</br>

> ## Java 코드


   ```
    
  ```

> ## 시간복잡도

-  O(n²) 이다.
<br/>


<br/>
<br/>

# 5. 병합 정렬(Merge Sort)

- 리스트 분할을 반복하여 최대한 작게 쪼개진 시점에서 인접한 원소들끼리 비교하여 정렬하는 방식이다.
- 기본적으로 '분할 정복' 알고리즘을 기반으로 정렬이 진행된다.
- 퀵 정렬과 유사한 방식이지만 퀵 정렬은 피벗을 통해 먼저 정렬하고 영역을 쪼개는 것이고,</br>
- 병합정렬은 영역을 쪼갤 수 있을 만큼 쪼갠 후에 정렬한다는 차이가 있다.
- 데이터를 '비교'하며 찾기 때문에'비교 정렬'이며</br>
정렬 과정에서 추가적인 공간을 필요로 하기 때문에 '제자리 정렬(in=place sort)'이 아니다.
- 문제를 작게 쪼개어 앞부터 합쳐나가기 때문에 안정 정렬(Stable Sort)이다.
</br>

- 정렬 과정
  - 주어진 리스트를 절반으로 분할하여 부분리스트로 나눈다.
  - 해당 부분리스트의 길이가 1이 될때까지 분할 과정을 반복한다.
  - 인접한 부분리스트끼리 정렬하여 합친다(이 과정에서 자연스럽게 정렬이 진행된다).
</br>
      <img width="600" src="">
<br/>
</br>

> ## Java 코드

  ```
    public class Test {
	public static int[] tmp; // 배열의 값을 잠시 복사해둘 공간
	public static void main(String[] args) throws IOException {
		int[] arr = { 3, 1, 7, 4, 5, 6, 8, 2 };
		mergeSort(arr);
	}
 
	public static void mergeSort(int[] arr) {
		tmp = new int[arr.length];
		mergeSort(arr, 0, arr.length - 1);
	}
 
	private static void mergeSort(int[] arr, int start, int end) {
		// 원소가 2개 이상이라면
		if(start < end) {
			// 중앙 값을 구하고
			int mid = (start + end) / 2;
			// 중앙을 기준으로 2개의 그룹으로 분할
			mergeSort(arr, start, mid);
			mergeSort(arr, mid+1, end);
			// 정렬 후 병합
			merge(arr, start, mid, end);
		}
	}
 
	private static void merge(int[] arr, int start, int mid, int end) {
		// 배열 복사
		tmp = arr.clone();
		
		/*
		 * part1: 왼쪽 그룹의 시작 인덱스
		 * part2: 오른쪽 그룹의 시작 인덱스
		 * index: 정렬된 값을 병합된 배열의 어떤 위치에 넣어야하는 지
		 */
		int part1 = start;
		int part2 = mid + 1;
		int index = start;
		
		// 두 그룹중 한쪽의 원소가 오링날때까지 반복 (정렬 & 합병)
		while(part1 <= mid && part2 <= end) {
			if(tmp[part1] <= tmp[part2]) {
				arr[index++] = tmp[part1++];
			} else {
				arr[index++] = tmp[part2++];
			}
		}
		
		// 왼쪽 그룹의 원소가 남는 경우 처리
		// (오른쪽 그룹의 원소가 남는 경우는 따로 처리하지 않아도 된다)
		for(int i=0; i<=mid-part1; i++) {
			arr[index+i] = tmp[part1+i];
		}
	}
}
  ```

> ## 시간복잡도

- n개의 데이터를 가지고 logn단계를 거치기 때문에 O(nlogn)이 된다.
- 언제나 절반씩 분할이 되기 때문에 항상 O(nlogn)의 시간 복잡도를 보장한다는 장점이 있다.(퀵 정렬과의 차이)
<br/>


<br/>
<br/>


<br/>
<br/>
