# 세그먼트 트리
- 여러 개의 데이터가 연속적으로 존재할 때 **데이터 변경, 특정 구간 합, 최소값, 최댓값** 등을 빠르게 구할 수 있는 알고리즘
- 시간복잡도
  - 데이터 변경 O(logN)
  - 연산 O(logN)
  - 데이터 변경할 때마다 M번 연산 : O(MlogN)

# 누적합과 비교
- 데이터 변경이 없다면 시간 복잡도는 O(1)이지만 데이터 변경이 있다면 해당 원소를 포함하는 구간을 모두 업데이트해야 하므로 O(N)이 걸리게 된다.
- 세그먼트 트리를 사용하면 연산과 데이터 변경 모두 O(logN)으로 가능하다.


# 예시
<a href="https://www.acmicpc.net/problem/2042">[백준 2042] 구간 합 구하기</a>

## 예제 입력 1
```
5 2 2
1
2
3
4
5
1 3 6
2 2 5
1 5 2
2 3 5
```

## 예제 출력 2
```
17
12
```

## 세그먼트 트리
![KakaoTalk_20231226_082757301](https://github.com/SSAFYSEOUL06CSSTUDY/06CSSTUDY/assets/50236187/935e28c0-8ab5-4ba2-9226-d0588d34c98c)
```java
static public class SegmentTree {
		long tree[]; // 각 원소가 담길 트리
		int treeSize; // 트리의 크기

		public SegmentTree(int arrSize) {
			// 트리 높이 구하기
			int h = (int) Math.ceil(Math.log(arrSize) / Math.log(2));
			// 높이를 이용한 배열 사이즈 구하기
			this.treeSize = (int) Math.pow(2, h + 1);
			// 배열 생성
			tree = new long[treeSize];
		}

// arr: 원소배열, node: 현재노드, start: 현재구간 배열 시작, end: 현재구간 배열 끝
		public long init(long[] arr, int node, int start, int end) {
			// 배열의 시작과 끝이 같다면 leaf 노드이므로
			// 원소 배열값 그대로 담기
			if (start == end)
				return tree[node] = arr[start];
			// leaf 노드가 아니면, 자식노드 합 담기
			return tree[node] = init(arr, node * 2, start, (start + end) / 2)
					+ init(arr, node * 2 + 1, (start + end) / 2 + 1, end);
		}

...
}
```

## 데이터 변경(update)
![KakaoTalk_20231226_082757301_01](https://github.com/SSAFYSEOUL06CSSTUDY/06CSSTUDY/assets/50236187/dddecb16-8d5d-4d91-8aea-8b51f140c9d4)
```java
		// node: 현재노드 인덱스, start: 배열의 시작, end: 배열의 끝
		// idx: 변경할 데이터의 idx, diff: 원래 데이터 값과 변경 데이터값의 차이
		public void update(int node, int start, int end, int idx, long diff) {
			// 만약 변경할 index 값이 범위 밖이면 확인 불필요
			if (idx < start || idx > end)
				return;

			// 차를 저장
			tree[node] += diff;

			// leaf노드가 아니면 아래 자식들도 확인
			if (start != end) {
				update(node * 2, start, (start + end) / 2, idx, diff);
				update(node * 2 + 1, (start + end) / 2 + 1, end, idx, diff);
			}
		}
```

## 누적합(sum)
![KakaoTalk_20231226_082757301_02](https://github.com/SSAFYSEOUL06CSSTUDY/06CSSTUDY/assets/50236187/7f5378dc-c77a-4eb8-9155-14c7d9e22df7)
```java
// node:현재 노드, start:배열의 시작, end: 배열의 끝
		// left:원하는 누적합의 시작, right:원하는 누적합의 끝
		public long sum(int node, int start, int end, int left, int right) {
			// 범위를 벗어나는 경우 더할 필요 없음
			if (left > end || right < start)
				return 0;

			// 범위 내에 완전히 포함될 경우 더 내려가지 않고 바로 리턴
			if (left <= start && end <= right)
				return tree[node];

			// 그 외의 경우 좌/우측으로 지속 탐색 수행
			return sum(node * 2, start, (start + end) / 2, left, right)
					+ sum(node * 2 + 1, (start + end) / 2 + 1, end, left, right);
		}
```

## 전체 코드
```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken()); // 수의 개수
		int M = Integer.parseInt(st.nextToken()); // 데이터 변경 개수
		int K = Integer.parseInt(st.nextToken()); // 구간합 구하는 횟수

		long[] arr = new long[N + 1];
		for (int i = 1; i <= N; i++) {
			arr[i] = Long.parseLong(br.readLine());
		}

		SegmentTree stree = new SegmentTree(N);

		stree.init(arr, 1, 1, N);

		for (int i = 0; i < M + K; i++) {
			st = new StringTokenizer(br.readLine());
			// 명령어
			int cmd = Integer.parseInt(st.nextToken());
			int a = Integer.parseInt(st.nextToken());
			// 원소의 범위는 2^63이므로 롱타입으로 받아야한다.
			long b = Long.parseLong(st.nextToken());

			// 데이터 변경 명령어
			if (cmd == 1) {
				stree.update(1, 1, N, a, b - arr[a]);
				arr[a] = b;
			} else {
				bw.write(stree.sum(1, 1, N, a, (int) b) + "\n");
			}
		}
		bw.flush();
		bw.close();
		br.close();
	}

	static public class SegmentTree {
		long tree[]; // 각 원소가 담길 트리
		int treeSize; // 트리의 크기

		public SegmentTree(int arrSize) {
			// 트리 높이 구하기
			int h = (int) Math.ceil(Math.log(arrSize) / Math.log(2));
			// 높이를 이용한 배열 사이즈 구하기
			this.treeSize = (int) Math.pow(2, h + 1);
			// 배열 생성
			tree = new long[treeSize];
		}

		// arr: 원소배열, node: 현재노드, start: 현재구간 배열 시작, end: 현재구간 배열 끝
		public long init(long[] arr, int node, int start, int end) {
			// 배열의 시작과 끝이 같다면 leaf 노드이므로
			// 원소 배열값 그대로 담기
			if (start == end)
				return tree[node] = arr[start];
			// leaf 노드가 아니면, 자식노드 합 담기
			return tree[node] = init(arr, node * 2, start, (start + end) / 2)
					+ init(arr, node * 2 + 1, (start + end) / 2 + 1, end);
		}

		// node: 현재노드 인덱스, start: 배열의 시작, end: 배열의 끝
		// idx: 변경할 데이터의 idx, diff: 원래 데이터 값과 변경 데이터값의 차이
		public void update(int node, int start, int end, int idx, long diff) {
			// 만약 변경할 index 값이 범위 밖이면 확인 불필요
			if (idx < start || idx > end)
				return;

			// 차를 저장
			tree[node] += diff;

			// leaf노드가 아니면 아래 자식들도 확인
			if (start != end) {
				update(node * 2, start, (start + end) / 2, idx, diff);
				update(node * 2 + 1, (start + end) / 2 + 1, end, idx, diff);
			}
		}

		// node:현재 노드, start:배열의 시작, end: 배열의 끝
		// left:원하는 누적합의 시작, right:원하는 누적합의 끝
		public long sum(int node, int start, int end, int left, int right) {
			// 범위를 벗어나는 경우 더할 필요 없음
			if (left > end || right < start)
				return 0;

			// 범위 내에 완전히 포함될 경우 더 내려가지 않고 바로 리턴
			if (left <= start && end <= right)
				return tree[node];

			// 그 외의 경우 좌/우측으로 지속 탐색 수행
			return sum(node * 2, start, (start + end) / 2, left, right)
					+ sum(node * 2 + 1, (start + end) / 2 + 1, end, left, right);
		}
	}

}
```
