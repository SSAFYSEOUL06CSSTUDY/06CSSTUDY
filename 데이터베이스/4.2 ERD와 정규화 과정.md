# 4.2.1 ERD의 중요성 

ERD는 데이터 베이스를 구축할때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것이다. 

* 시스템의 요구사항을 기반으로 작성. 
* 이를 기반으로 데이터베이스를 구축. 
* 구축한 후에도 디버깅 또는 비지니스 프로세스 재설계가 필요한 경우 설계도의 역할. 

ERD는 관계형 구조로 표현할 수 있는 데이터를 구성하는데 유용할 수 있지만 비정형 데이터를 충분히 표현할 수 없다는 단점이 있다. 

> 비정형 데이터 : 정의된 구조가 없이 정형화되지 않은 데이터. 대표적인 비정형 데이터에는 동영상 파일, 오디오 파일, 사진, 보고서(문서), 메일 본문 등이 있다.

<br>

# 4.2.2 예제로 배우는 ERD

* '|' 표시가 있는 곳은 반드시 있어야 하는 개체. (필수)
* 'O' 표시가 있다면 없어도 되는 개체. (선택)

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/abb5a547-3a14-4a98-82b6-edaa992f355f">

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/7734bc9d-ceaa-48a6-82a2-7cf88c5c8bf3">

<br>

# 4.2.3 정규화 과정 

### 정규화 과정이란? 
릴레이션 간의 잘못된 종속관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러개로 분리하는 과정이다. 
> 데이터 베이스 이상 현상 : 삽입 이상, 업데이트 이상, 삭제 이상이 있다.
> * 삽입 이상 : 특정 데이터가 존재하지 않아 중요한 데이터를 데이터베이스에 삽입할 수 없을 때 발생한다.
> * 업데이트 이상 : 테이블의 특정 데이터를 업데이트 했는데, 정상적으로 변경되지 않은 경우, 또는 너무 많은 행을 업데이트 하는 경우.
> * 삭제 이상 : 특정 정보를 삭제하면, 원치 않는 정보도 삭제되는 현상.

정규화과정은 정규형 원칙을 기반으로 정규형을 만들어가는 과정이다. <br>
정규화된 정도는 정규형으로 표현한다. 

* 기본 정규형 : 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형
* 고급 정규형 : 제4정규형, 제 5정규형

### 정규형 원칙
같은 의미를 표현하는 릴레이션이지만 
* 좀 더 좋은 구조.
* 자료의 중복 감소.
* 독립적인 관계는 별개의 릴레이션으로 표현.
* 각각의 릴레이션은 독립적으로 표현 가능.

## 제 1 정규형 

릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값만으로 구성되어야 한다. <br>
한개의 기본키에 대해 두개 이상의 값을 가지는 반복 집합이 있으면 안된다. 있다면 제거.  <br>
테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/b97a2737-7084-4fc4-aab3-2b05fb389719">

위의 테이블에서 "장영"은 좋아하는 음식이 2가지 이므로 컬럼이 원자값을 가지지 않아 1차 정규형을 만족하지 못하고 있다.  <br>
따라서 아래와 같이 테이블을 분해하여, 칼럼이 원자값을 가지도록 한다. 

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/93d37cd8-25a5-4822-87f7-3966e64ec1f6">

## 제 2 정규형 

1. 1정규형을 만족해야 한다. <br>
2. 모든 컬럼이 부분적 종속(Partial Dependency)이 없어야 한다. == 모든 칼럼이 완전 함수 종속을 만족해야 한다.

기본키 중에 특정 컬럼에만 종속된 컬럼이 없어야 된다.

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/986107bc-273e-4d66-a29f-6820925c68ff">

위 테이블의 기본키는 (이름, 좋아하는 음식)으로 복합키이다. 이 두 개가 합쳐져야 한 로우를 구분할 수가 있다. <br>
근데 '나이'의 경우 이 기본키 중에 '이름'에만 종속되어 있다.<br>
즉, '이름' 컬럼의 값을 알면 '나이'의 값을 알 수 있다. 따라서 '나이'가 두 번 들어가는 것은 불필요한 것이다.

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/4d41a479-a217-4b82-ba30-a973aa2ad3ef">

주의 : 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 한다. 


## 제 3 정규형

릴레이션이 제 2 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형이다. 

> 이행적 함수 종속이란 ? <br> 
> 이행적 함수 종속: A -> B -> C 가 존재하면 A -> C 가 성립한다. <br>
> 이때 집합 C가 집합 A에 이행적으로 함수 종속되었다고 한다. 

즉, 기본키 이외에 다른 컬럼이 그 외의 다른 컬럼을 결정할 수 없다는 것을 의미.

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/2c7c4859-ab99-4103-8ddd-79d37880630a">

위의 테이블을 보면 'zip code' 키를 통해 '도시'를 결정할 수 있다.  <br>
여러 사람들이 동일한 'zip code'를 가지면 '도시'가 결정되기 때문에, 이 컬럼들에는 중복된 데이터가 생길 수 있다. 

이를 해결하기 위해서, 테이블을 논리적인 단위(사람, 주소)로 분리한다.

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/b3c9cd8e-54d6-43ad-82b7-43d0f0fa9399">

## 보이스 / 코드 정규형 

제 3 정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 종속 관계에서 모든 결정자가 후보키인 상태를 말한다. 

후보키는 최소성과 유일성을 만족해야 한다. 즉 후보키만으로 릴레이션에서 튜플을 특정할 수 있는 능력이 있어야 하며, 유일성을 가지는 데 꼭 필요한 속성들만으로 구성되어야 한다.

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/c66ca6e0-325b-4f7c-86dd-83c50d69939f">

위의 테이블에서 기본키는(이름, 과목)이다. 이 기본키(이름, 과목)은 '교수님'을 결정짓고, '교수님'은 '과목'을 결정짓는다. 하지만 여기서 '교수님'은 결정자지만 후보키가 아니다는 문제가 있다.  이 경우,  만약 '과목'이 변경되면, '교수님'도 변경해야 갱신 문제가 발생할 수 있다. 

아래와 같이 테이블을 2개로 분해하면 BCNF화를 할 수 있다.  

<img  width ="600" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/ec15b629-f509-4384-90e9-4786dde92cde">

해당 정규형을 거쳐 테이블을 나눈다고 해서 성능이 100프로 좋아지는 것은 아니다. 성능이 좋아질 수도 나빠질 수도 있다. 테이블을 나누게 되면 어떠한 쿼리는 조인을 해야하는 경우도 발생해서 오히려 느려질 수 있기 때문에 서비스에 따라 정규화 또는 비정규화 과정을 진행해야 한다.
