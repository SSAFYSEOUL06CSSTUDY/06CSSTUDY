### 목차

1. [**인증방식**](#1-인증방식)
2. [**Jwt란?**](#2-jwt란?)
3. [**Jwt 인증 과정**](#3-jwt-인증-과정)
4. [**Jwt Refresh Token**](#4-jwt-refresh-token)

# Jwt

> JWT 토큰을 이용한 웹 인증 인가 방식
<img width="909" alt="스크린샷 2023-10-18 오전 5 47 18" src="https://github.com/SSAFYSEOUL06CSSTUDY/06CSSTUDY/assets/108852263/68680019-10b3-418e-a079-937d83598b33">

# 1. 인증방식

## 1-1. Cookie 인증

> key-value 형식의 문자열인 쿠키를 이용한 인증인가방식

- 1 단계) 브라우저-클라이언트 가 서버로 접속(요청)
- 2 단계) 서버는 클라이언트에게 응답 할때, 응답 헤더의 Set-Cookie에 필요한 인증 정보를 담는다.
- 3 단계) 이후 클라이언트는 요청 할때마다 해당 쿠키를 함께 서버로 보내고, 서버는 해당 쿠키로 클라이언트를 식별

> Cookie 인증 방식의 단점

- 쿠키 값이 그대로 노출되기에 보안에 취약
- 다소 아쉬운 용량 제한
- 브라우저마다 쿠키 지원 방식이 상이해 브라우저간 호환(크로스 플랫폼)이 어려움

## 1-2. Session 인증

> 쿠키의 취약한 보안을 보완하기 위한 방식<br>
> 중요한 인증 정보를 클라이언트가 아닌 서버에 보관

- 1 단계) 클라이언트에 유저가 로그인시 클라이언트의 쿠키에는 세션ID, 서버에는 해당 세션이 저장
- 2 단계) 클라이언트는 모든 요청에 쿠키의 세션 ID를 담아 전소
- 3 단계) 서버는 요청의 세션ID와 서버의 세션을 비교하여 요청을 처리

> Session 인증 방식의 단점

- 세션ID가 탈취 당하면 결국 서버에 위장 접속이 가능하다는 점은 동일하다
- 세션 정보 저장과 처리를 서버에서 전부 처리하므로 접속량이 증가하면 서버의 부담이 증가

## 1-3. Token 인증

> Cookie 인증과 Session 인증 방식이 혼합된 방식<br>
> 암호화된 토큰을 클라이언트에 저장하고 서버에서는 요청이 올때 일치 여부만 확인

- 1 단계) 클라이언트에 유저가 로그인시 인증 정보가 담긴 토큰을 쿠키 혹은 로컬스토리지에 저장
- 2 단계) 클라이언트는 모든 요청에 해당 토큰을 헤더에 담아 전송
- 3 단계) 서버는 해당 토큰을 복호화(암호를 푸는 것)하여 토큰을 검증, 이떄 해당 유저 정보는 토큰에 암호화 되어 있으므로, DB를 조회하지 않고 처리 가능

> Token 인증 방식의 단점

- 암호화된 토큰 문자열의 길이가 길어, 인증 요청이 늘어나면 부하 발생
- 토큰 인증 방식도 탈취 문제를 완벽하게 해결하지는 못함

# 2. Jwt란?

> JWT(JSON Web Token)의 약어<br>
> 인증에 필요한 정보들을 암호화시킨 JSON을 토큰화 시킨 것

![jwt_structure](https://github.com/SSAFYSEOUL06CSSTUDY/06CSSTUDY/assets/108852263/37f096b0-9475-40c0-807e-e686f0cf7685)


## 2-1. Jwt 토큰의 구조

> Jwt 토큰은 헤더(Header), 내용(Payload), 서명(Signature) 3가지 문자열로 구성

## Header

> JWT 에서 사용할 타입(typ)과 해시 알고리즘의 종류(alg)에 대한 정보

    {
        "alg" : "HS256",
        "typ" : "JWT"
    }

해시 알고리즘의 종류 : HSA256, HSA512, RSA 등

## Payload

> 정보들의 조각인 "claim"이 담겨있다. claim은 json 데이터쌍이라고 이해하면 좋다.

    {
        iss : "kh109",
        exp : 150000,
        Key1 : "Value1",
        Key2 : "Value2",
        Key3 : "Value3"
    }

- Registed claims : 미리 정의된 클레임.
  <br> &nbsp; iss(issuer) : 토큰 발급자,
  <br> &nbsp; sub(Subject) : 토큰 제목 - 사용자가 누구인지 식별할때 사용,
  <br> &nbsp; aud(Audience) : 토큰 대상자,
  <br> &nbsp; exp(Expiration Time) : 토큰 만료 시간,
  <br> &nbsp; nbf(Not Before) : 토큰 활성 날짜 - 이 날짜 이전 값은 유효하지 않다는 뜻,
  <br> &nbsp; iat(issued At) : 토큰 발급 시간,
  <br> &nbsp; jti(JWI ID) : iss가 여러 명일 때 구분하기 위한 ID 값
  <br>

- Public claims : 사용자가 정의할 수 있는 클레임
- Private claims : 외부에 공개되도 상관없지만 해당 유저를 특정할 수 있는 정보가 담김

  > Header 와 Payload는 암호화 없이 BASE64형식으로 인코딩만 진행한다(암호화는 아니다).

      SSAFY =(BASE64 인코딩)=> U1NBRlk=

## Signature

> Header, Payload와 다르게 서버에서 관리하는 비밀키 값이 있어야지만 복호화가 가능한 문자열<br>

    {
        Base64 암호화(헤더).Base64 암호화(페이로드), 서버 비밀키 값
    }

# 3. Jwt 인증 과정

- 1 단계) 클라이언트에서 유저가 로그인 요청
- 2 단계) 서버에서 JWT 발급하여 응답 헤더(쿠키 형식으로)에 담아 전달
- 3 단계) 클라이언트는 해당 토큰을 쿠키 or 로컬 스토리지에 담아 저장
- 4 단계) 이후 클라이언트는 매 요청시마다 헤더에 인증 토큰을 담아 전달
- 5 단계) 서버는 해당 토큰이 서버에서 생성한 토큰인지 여부만 체크해서 문제가 없다면 통과, DB 조회없이 해당 토큰에 있는 유저정보를 클라이언트로 반환

  > 이렇게 단순한데 토큰의 의미가 있을까?

- 유저 JWT: A(Header) + B(Payload) + C(Signature) 일 때 해커가 B를 임의로 수정 -> 유저 JWT: A + 수정된B + 수정된C(B가 수정되면 C도 따라서 수정된다)
- 수정한 토큰을 서버에 요청을 보내면 서버는 유효성 검사 시행
- 요청이 간 JWT : A+B'+C' / 서버 기록에 있는 JWT : A+B+C
- 서버에 있는 시크릿 값을 알아야 C 값까지 조작 할 수 있고, 무엇보다 C가 동일하지 않으면 서버에서 거부
  > 이 과정을 통해 JWT 토큰은 신뢰성 확보(위조 방지)

# 4. Jwt Refresh Token

> JWT 토큰 또한 탈취의 위험성에서 벗어 날 수 없기에 유효기간을 최대한 짧게 설정하여, 토큰이 탈취 되어도 큰 문제가 없도록 대비한다.

> 하지만 짧은 유효기간은 로그인을 자주 해야하는 문제점이 발생

> 이를 위해 로그인을 할 필요 없이 리프레쉬 토큰이 있다면 인증 토큰을 재발급하는 방식의 이중 토큰 방식을 현재 주로 사용
